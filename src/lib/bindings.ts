// @ts-nocheck
// Auto-generated by tauri-specta. DO NOT EDIT.


// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
/**
 * Simple greeting command for demonstration purposes.
 */
async greet(name: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("greet", { name }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Loads user preferences from disk.
 * Returns default preferences if the file doesn't exist.
 */
async loadPreferences() : Promise<Result<AppPreferences, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("load_preferences") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Saves user preferences to disk.
 * Uses atomic write (temp file + rename) to prevent corruption.
 */
async savePreferences(preferences: AppPreferences) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_preferences", { preferences }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets the current application version from Cargo.toml.
 */
async getAppVersion() : Promise<string> {
    return await TAURI_INVOKE("get_app_version");
},
/**
 * Sends a native system notification.
 * On mobile platforms, returns an error as notifications are not yet supported.
 */
async sendNativeNotification(title: string, body: string | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("send_native_notification", { title, body }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Saves emergency data to a JSON file for later recovery.
 * Validates filename and enforces a 10MB size limit.
 */
async saveEmergencyData(filename: string, data: JsonValue) : Promise<Result<null, RecoveryError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_emergency_data", { filename, data }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Loads emergency data from a previously saved JSON file.
 * Returns FileNotFound if the file doesn't exist.
 */
async loadEmergencyData(filename: string) : Promise<Result<JsonValue, RecoveryError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("load_emergency_data", { filename }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Removes recovery files older than 7 days.
 * Returns the count of removed files.
 */
async cleanupOldRecoveryFiles() : Promise<Result<number, RecoveryError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("cleanup_old_recovery_files") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets the path to the Factory config file
 */
async getConfigPath() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_config_path") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Resets the config file to an empty JSON object
 */
async resetConfigFile() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_config_file") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Loads custom models from settings.json
 */
async loadCustomModels() : Promise<Result<CustomModel[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("load_custom_models") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Saves custom models to settings.json (preserves other fields)
 */
async saveCustomModels(models: CustomModel[]) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_custom_models", { models }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Checks if legacy config.json exists and settings.json has customModels
 */
async checkLegacyConfig() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_legacy_config") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Deletes the legacy config.json file
 */
async deleteLegacyConfig() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_legacy_config") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Fetches available models from a provider API
 */
async fetchModels(provider: Provider, baseUrl: string, apiKey: string) : Promise<Result<ModelInfo[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_models", { provider, baseUrl, apiKey }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets the default model ID from sessionDefaultSettings.model
 */
async getDefaultModel() : Promise<Result<string | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_default_model") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Saves the default model ID to sessionDefaultSettings.model
 */
async saveDefaultModel(modelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_default_model", { modelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets the cloudSessionSync setting from settings.json
 * Returns true by default if not set
 */
async getCloudSessionSync() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_cloud_session_sync") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Saves the cloudSessionSync setting to settings.json
 */
async saveCloudSessionSync(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_cloud_session_sync", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets the reasoningEffort setting from settings.json
 * Returns None if not set (model-dependent default)
 */
async getReasoningEffort() : Promise<Result<string | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_reasoning_effort") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Saves the reasoningEffort setting to settings.json
 */
async saveReasoningEffort(value: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_reasoning_effort", { value }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets the diffMode setting from settings.json
 * Returns "github" by default if not set
 */
async getDiffMode() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_diff_mode") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Saves the diffMode setting to settings.json
 */
async saveDiffMode(value: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_diff_mode", { value }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets the todoDisplayMode setting from settings.json
 * Returns "pinned" by default if not set
 */
async getTodoDisplayMode() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_todo_display_mode") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Saves the todoDisplayMode setting to settings.json
 */
async saveTodoDisplayMode(value: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_todo_display_mode", { value }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets the includeCoAuthoredByDroid setting from settings.json
 * Returns true by default if not set
 */
async getIncludeCoAuthoredByDroid() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_include_co_authored_by_droid") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Saves the includeCoAuthoredByDroid setting to settings.json
 */
async saveIncludeCoAuthoredByDroid(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_include_co_authored_by_droid", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets the showThinkingInMainView setting from settings.json
 * Returns false by default if not set
 */
async getShowThinkingInMainView() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_show_thinking_in_main_view") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Saves the showThinkingInMainView setting to settings.json
 */
async saveShowThinkingInMainView(enabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_show_thinking_in_main_view", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Loads all channels from ~/.droidgear/channels.json
 * Falls back to ~/.factory/settings.json for migration
 */
async loadChannels() : Promise<Result<Channel[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("load_channels") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Saves all channels to ~/.droidgear/channels.json
 */
async saveChannels(channels: Channel[]) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_channels", { channels }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Saves a channel's credentials to ~/.droidgear/auth/
 */
async saveChannelCredentials(channelId: string, username: string, password: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_channel_credentials", { channelId, username, password }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets a channel's credentials from ~/.droidgear/auth/
 */
async getChannelCredentials(channelId: string) : Promise<Result<[string, string] | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_channel_credentials", { channelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Deletes a channel's credentials from ~/.droidgear/auth/
 */
async deleteChannelCredentials(channelId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_channel_credentials", { channelId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Detects channel type by probing characteristic endpoints
 */
async detectChannelType(baseUrl: string) : Promise<Result<ChannelType, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("detect_channel_type", { baseUrl }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Fetches tokens from a channel (dispatches based on channel type)
 */
async fetchChannelTokens(channelType: ChannelType, baseUrl: string, username: string, password: string) : Promise<Result<ChannelToken[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_channel_tokens", { channelType, baseUrl, username, password }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Fetches models using an API key (for quick model addition from channels)
 */
async fetchModelsByApiKey(baseUrl: string, apiKey: string, platform: string | null) : Promise<Result<ModelInfo[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_models_by_api_key", { baseUrl, apiKey, platform }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets the value of an environment variable.
 * Returns None if the variable is not set.
 */
async getEnvVar(name: string) : Promise<string | null> {
    return await TAURI_INVOKE("get_env_var", { name });
},
/**
 * Sets an environment variable for the current process.
 * Note: This only affects the current process, not the system or shell.
 */
async setEnvVar(name: string, value: string) : Promise<void> {
    await TAURI_INVOKE("set_env_var", { name, value });
},
/**
 * Removes an environment variable from the current process.
 * Note: This only affects the current process, not the system or shell.
 */
async removeEnvVar(name: string) : Promise<void> {
    await TAURI_INVOKE("remove_env_var", { name });
},
/**
 * Gets environment variables from a login shell.
 * This is useful for GUI apps that don't inherit shell environment.
 * Uses non-interactive mode for faster execution.
 */
async getShellEnv() : Promise<Result<Partial<{ [key in string]: string }>, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_shell_env") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Lists all spec files from ~/.factory/specs directory.
 * Returns files sorted by modification time (newest first).
 */
async listSpecs() : Promise<Result<SpecFile[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_specs") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Reads a single spec file by path.
 */
async readSpec(path: string) : Promise<Result<SpecFile, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("read_spec", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Renames a spec file.
 */
async renameSpec(oldPath: string, newName: string) : Promise<Result<SpecFile, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("rename_spec", { oldPath, newName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Deletes a spec file.
 */
async deleteSpec(path: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_spec", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Updates a spec file content.
 */
async updateSpec(path: string, content: string) : Promise<Result<SpecFile, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_spec", { path, content }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Starts watching the specs directory for changes.
 * Emits "specs-changed" event when files are added, modified, or removed.
 */
async startSpecsWatcher() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_specs_watcher") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Stops watching the specs directory.
 */
async stopSpecsWatcher() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stop_specs_watcher") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Loads all MCP servers from ~/.factory/mcp.json
 */
async loadMcpServers() : Promise<Result<McpServer[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("load_mcp_servers") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Saves an MCP server (creates or updates)
 */
async saveMcpServer(server: McpServer) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_mcp_server", { server }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Deletes an MCP server by name
 */
async deleteMcpServer(name: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_mcp_server", { name }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Toggles an MCP server's disabled state
 */
async toggleMcpServer(name: string, disabled: boolean) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("toggle_mcp_server", { name, disabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * 列出所有 Codex Profiles
 */
async listCodexProfiles() : Promise<Result<CodexProfile[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_codex_profiles") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * 获取指定 Profile
 */
async getCodexProfile(id: string) : Promise<Result<CodexProfile, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_codex_profile", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * 保存 Profile（新建或更新）
 */
async saveCodexProfile(profile: CodexProfile) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_codex_profile", { profile }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * 删除 Profile
 */
async deleteCodexProfile(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_codex_profile", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * 复制 Profile
 */
async duplicateCodexProfile(id: string, newName: string) : Promise<Result<CodexProfile, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("duplicate_codex_profile", { id, newName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * 创建默认 Profile（当无 Profile 时调用）
 */
async createDefaultCodexProfile() : Promise<Result<CodexProfile, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_default_codex_profile") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * 读取 active Profile ID
 */
async getActiveCodexProfileId() : Promise<Result<string | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_active_codex_profile_id") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * 应用指定 Profile 到 `~/.codex/*`
 */
async applyCodexProfile(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("apply_codex_profile", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * 获取 Codex Live 配置状态（文件是否存在及路径）
 */
async getCodexConfigStatus() : Promise<Result<CodexConfigStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_codex_config_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * 读取当前 `~/.codex/*` 配置（若不存在则返回空）
 */
async readCodexCurrentConfig() : Promise<Result<CodexCurrentConfig, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("read_codex_current_config") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all profiles
 */
async listOpencodeProfiles() : Promise<Result<OpenCodeProfile[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_opencode_profiles") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get a single profile by ID
 */
async getOpencodeProfile(id: string) : Promise<Result<OpenCodeProfile, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_opencode_profile", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Save a profile
 */
async saveOpencodeProfile(profile: OpenCodeProfile) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_opencode_profile", { profile }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete a profile
 */
async deleteOpencodeProfile(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_opencode_profile", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Duplicate a profile
 */
async duplicateOpencodeProfile(id: string, newName: string) : Promise<Result<OpenCodeProfile, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("duplicate_opencode_profile", { id, newName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create default profile if none exists
 */
async createDefaultProfile() : Promise<Result<OpenCodeProfile, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_default_profile") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get active profile ID
 */
async getActiveOpencodeProfileId() : Promise<Result<string | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_active_opencode_profile_id") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Apply a profile to OpenCode config files (merge write)
 * Supports both .json and .jsonc files, preferring .jsonc when both exist
 */
async applyOpencodeProfile(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("apply_opencode_profile", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get OpenCode config status
 * Returns actual file paths, preferring .jsonc over .json when both exist
 */
async getOpencodeConfigStatus() : Promise<Result<OpenCodeConfigStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_opencode_config_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get provider templates
 */
async getOpencodeProviderTemplates() : Promise<Result<ProviderTemplate[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_opencode_provider_templates") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Test provider connection
 */
async testOpencodeProviderConnection(providerId: string, baseUrl: string, apiKey: string) : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("test_opencode_provider_connection", { providerId, baseUrl, apiKey }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Read current OpenCode configuration from config files
 * Returns providers from opencode.json/jsonc and auth from auth.json/jsonc
 * Also extracts apiKey from provider.options.apiKey if auth.json doesn't have it
 */
async readOpencodeCurrentConfig() : Promise<Result<OpenCodeCurrentConfig, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("read_opencode_current_config") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * List all OpenClaw Profiles
 */
async listOpenclawProfiles() : Promise<Result<OpenClawProfile[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_openclaw_profiles") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get a single profile by ID
 */
async getOpenclawProfile(id: string) : Promise<Result<OpenClawProfile, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_openclaw_profile", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Save a profile (create or update)
 */
async saveOpenclawProfile(profile: OpenClawProfile) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_openclaw_profile", { profile }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete a profile
 */
async deleteOpenclawProfile(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_openclaw_profile", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Duplicate a profile
 */
async duplicateOpenclawProfile(id: string, newName: string) : Promise<Result<OpenClawProfile, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("duplicate_openclaw_profile", { id, newName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Create default profile (when no profiles exist)
 * If openclaw.json exists, initialize profile from its content
 */
async createDefaultOpenclawProfile() : Promise<Result<OpenClawProfile, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_default_openclaw_profile") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get active profile ID
 */
async getActiveOpenclawProfileId() : Promise<Result<string | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_active_openclaw_profile_id") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Apply a profile to `~/.openclaw/openclaw.json`
 */
async applyOpenclawProfile(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("apply_openclaw_profile", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get OpenClaw config status
 */
async getOpenclawConfigStatus() : Promise<Result<OpenClawConfigStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_openclaw_config_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Read current OpenClaw configuration from config file
 */
async readOpenclawCurrentConfig() : Promise<Result<OpenClawCurrentConfig, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("read_openclaw_current_config") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Lists all session projects from ~/.factory/sessions directory.
 */
async listSessionProjects() : Promise<Result<SessionProject[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_session_projects") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Lists all sessions, optionally filtered by project.
 */
async listSessions(project: string | null) : Promise<Result<SessionSummary[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_sessions", { project }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets detailed session information including messages.
 */
async getSessionDetail(sessionPath: string) : Promise<Result<SessionDetail, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_session_detail", { sessionPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Starts watching the sessions directory for changes.
 */
async startSessionsWatcher() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_sessions_watcher") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Stops watching the sessions directory.
 */
async stopSessionsWatcher() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stop_sessions_watcher") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Deletes a session by removing its .jsonl and .settings.json files.
 */
async deleteSession(sessionPath: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_session", { sessionPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets the current configuration paths (custom values only)
 */
async getConfigPaths() : Promise<Result<ConfigPaths, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_config_paths") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets all effective paths with default indicators
 */
async getEffectivePaths() : Promise<Result<EffectivePaths, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_effective_paths") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Saves a single configuration path
 */
async saveConfigPath(key: string, path: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_config_path", { key, path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Resets a single configuration path to default
 */
async resetConfigPath(key: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_config_path", { key }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets the default paths (for UI display)
 */
async getDefaultPaths() : Promise<Result<EffectivePaths, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_default_paths") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

/**
 * Application preferences that persist to disk.
 * Only contains settings that should be saved between sessions.
 */
export type AppPreferences = { theme: string; 
/**
 * User's preferred language (e.g., "en", "es", "de")
 * If None, uses system locale detection
 */
language: string | null; 
/**
 * Whether the skip login feature is enabled
 * If None, defaults to false (disabled)
 */
skip_login_enabled?: boolean | null; 
/**
 * Custom font family for terminal (e.g., "Cascadia Mono NF")
 * If None, uses default monospace fonts
 */
terminal_font_family?: string | null; 
/**
 * Custom shell command for terminal (Windows only, e.g., "cmd.exe", "pwsh.exe")
 * If None, uses default PowerShell on Windows
 */
terminal_shell_command?: string | null }
/**
 * Channel configuration
 */
export type Channel = { 
/**
 * Unique identifier (UUID)
 */
id: string; 
/**
 * User-defined name
 */
name: string; 
/**
 * Channel type
 */
type: ChannelType; 
/**
 * API base URL
 */
baseUrl: string; 
/**
 * Whether the channel is enabled
 */
enabled: boolean; 
/**
 * Creation timestamp (milliseconds) - use f64 for JS compatibility
 */
createdAt: number }
/**
 * Token from channel API
 */
export type ChannelToken = { 
/**
 * Token ID from API
 */
id: number; 
/**
 * Token name
 */
name: string; 
/**
 * Token key (sk-xxx)
 */
key: string; 
/**
 * Status (1=enabled, 2=disabled, etc.)
 */
status: number; 
/**
 * Remaining quota
 */
remainQuota: number; 
/**
 * Used quota
 */
usedQuota: number; 
/**
 * Unlimited quota flag
 */
unlimitedQuota: boolean; 
/**
 * Platform type (openai, anthropic, gemini, etc.) - from Sub2API
 */
platform: string | null; 
/**
 * Group name - from Sub2API
 */
groupName: string | null }
/**
 * Channel types supported
 */
export type ChannelType = "new-api" | "sub-2-api"
/**
 * Codex Live 配置状态
 */
export type CodexConfigStatus = { authExists: boolean; configExists: boolean; authPath: string; configPath: string }
/**
 * 当前 Codex Live 配置（从 `~/.codex/*` 读取）
 */
export type CodexCurrentConfig = { auth?: Partial<{ [key in string]: JsonValue }>; configToml?: string }
/**
 * Codex Profile（用于在 DroidGear 内部保存并切换）
 */
export type CodexProfile = { id: string; name: string; description?: string | null; createdAt: string; updatedAt: string; auth?: Partial<{ [key in string]: JsonValue }>; configToml?: string }
/**
 * User-defined configuration paths (only stores explicitly set paths)
 */
export type ConfigPaths = { factory?: string | null; opencode?: string | null; opencodeAuth?: string | null; codex?: string | null }
/**
 * Message content block
 */
export type ContentBlock = { type: string; text?: string | null; thinking?: string | null }
/**
 * Custom model configuration
 */
export type CustomModel = { 
/**
 * Model identifier sent via API
 */
model: string; 
/**
 * Unique identifier for the model (e.g., "custom:ModelName-0")
 */
id?: string | null; 
/**
 * Index of the model in the list
 */
index?: number | null; 
/**
 * Human-friendly name shown in model selector
 */
displayName?: string | null; 
/**
 * API endpoint base URL
 */
baseUrl: string; 
/**
 * API key for the provider
 */
apiKey: string; 
/**
 * Provider type
 */
provider: Provider; 
/**
 * Maximum output tokens
 */
maxOutputTokens?: number | null; 
/**
 * Whether the model supports image inputs
 */
supportsImages?: boolean | null; 
/**
 * Additional provider-specific arguments
 */
extraArgs?: Partial<{ [key in string]: JsonValue }> | null; 
/**
 * Additional HTTP headers
 */
extraHeaders?: Partial<{ [key in string]: string }> | null }
/**
 * Effective path info with default indicator
 */
export type EffectivePath = { key: string; path: string; isDefault: boolean }
/**
 * All effective paths
 */
export type EffectivePaths = { factory: EffectivePath; opencode: EffectivePath; opencodeAuth: EffectivePath; codex: EffectivePath }
export type JsonValue = null | boolean | number | string | JsonValue[] | Partial<{ [key in string]: JsonValue }>
/**
 * MCP server entry with name
 */
export type McpServer = { 
/**
 * Server name (unique identifier)
 */
name: string; 
/**
 * Server configuration
 */
config: McpServerConfig }
/**
 * MCP server configuration
 */
export type McpServerConfig = { 
/**
 * Server type (stdio or http)
 */
type: McpServerType; 
/**
 * Whether the server is disabled
 */
disabled?: boolean; 
/**
 * Command to run (stdio only)
 */
command?: string | null; 
/**
 * Command arguments (stdio only)
 */
args?: string[] | null; 
/**
 * Environment variables (stdio only)
 */
env?: Partial<{ [key in string]: string }> | null; 
/**
 * HTTP URL (http only)
 */
url?: string | null; 
/**
 * HTTP headers (http only)
 */
headers?: Partial<{ [key in string]: string }> | null }
/**
 * MCP server type
 */
export type McpServerType = "stdio" | "http"
/**
 * Model info returned from API
 */
export type ModelInfo = { id: string; name: string | null }
/**
 * OpenClaw config status
 */
export type OpenClawConfigStatus = { configExists: boolean; configPath: string }
/**
 * Current OpenClaw configuration (from config files)
 */
export type OpenClawCurrentConfig = { defaultModel?: string | null; providers?: Partial<{ [key in string]: OpenClawProviderConfig }> }
/**
 * OpenClaw Model definition
 */
export type OpenClawModel = { id: string; name?: string | null; reasoning?: boolean; input?: string[]; contextWindow?: number | null; maxTokens?: number | null }
/**
 * OpenClaw Profile (stored in DroidGear)
 */
export type OpenClawProfile = { id: string; name: string; description?: string | null; createdAt: string; updatedAt: string; defaultModel?: string | null; providers?: Partial<{ [key in string]: OpenClawProviderConfig }> }
/**
 * OpenClaw Provider configuration
 */
export type OpenClawProviderConfig = { baseUrl?: string | null; apiKey?: string | null; api?: string | null; models?: OpenClawModel[] }
/**
 * Configuration status
 */
export type OpenCodeConfigStatus = { configExists: boolean; authExists: boolean; configPath: string; authPath: string }
/**
 * Current OpenCode configuration (providers and auth from config files)
 */
export type OpenCodeCurrentConfig = { providers: Partial<{ [key in string]: OpenCodeProviderConfig }>; auth: Partial<{ [key in string]: JsonValue }> }
/**
 * OpenCode Profile
 */
export type OpenCodeProfile = { id: string; name: string; description?: string | null; createdAt: string; updatedAt: string; providers: Partial<{ [key in string]: OpenCodeProviderConfig }>; auth: Partial<{ [key in string]: JsonValue }> }
/**
 * OpenCode Provider configuration
 */
export type OpenCodeProviderConfig = { npm?: string | null; name?: string | null; options?: OpenCodeProviderOptions | null }
/**
 * OpenCode Provider options
 */
export type OpenCodeProviderOptions = { baseUrl?: string | null; apiKey?: string | null; timeout?: number | null; headers?: Partial<{ [key in string]: string }> | null }
/**
 * Provider types supported by Factory BYOK
 */
export type Provider = "anthropic" | "openai" | "generic-chat-completion-api"
/**
 * Provider template for quick setup
 */
export type ProviderTemplate = { id: string; name: string; defaultBaseUrl?: string | null; requiresApiKey: boolean }
/**
 * Error types for recovery operations (typed for frontend matching)
 */
export type RecoveryError = 
/**
 * File does not exist (expected case, not a failure)
 */
{ type: "FileNotFound" } | 
/**
 * Filename validation failed
 */
{ type: "ValidationError"; message: string } | 
/**
 * Data exceeds size limit
 */
{ type: "DataTooLarge"; max_bytes: number } | 
/**
 * File system read/write error
 */
{ type: "IoError"; message: string } | 
/**
 * JSON serialization/deserialization error
 */
{ type: "ParseError"; message: string }
/**
 * Session detail with messages
 */
export type SessionDetail = { id: string; title: string; project: string; model: string; cwd: string; modifiedAt: number; tokenUsage: TokenUsage; messages: SessionMessage[] }
/**
 * Session message
 */
export type SessionMessage = { id: string; role: string; content: ContentBlock[]; timestamp: string }
/**
 * Session project (directory containing sessions)
 */
export type SessionProject = { 
/**
 * Directory name (e.g., "-Users-sunshow-GIT-sunshow-quickcast-api")
 */
name: string; 
/**
 * Full path to the directory
 */
path: string; 
/**
 * Number of sessions in this project
 */
sessionCount: number; 
/**
 * Last modified timestamp in milliseconds
 */
modifiedAt: number }
/**
 * Session summary for list view
 */
export type SessionSummary = { 
/**
 * Session UUID
 */
id: string; 
/**
 * Session title
 */
title: string; 
/**
 * Project directory name
 */
project: string; 
/**
 * Model used
 */
model: string; 
/**
 * Last modified timestamp in milliseconds
 */
modifiedAt: number; 
/**
 * Token usage
 */
tokenUsage: TokenUsage; 
/**
 * Full path to the session files (without extension)
 */
path: string }
/**
 * Spec file metadata
 */
export type SpecFile = { 
/**
 * File name (e.g., "2025-12-18-ui.md")
 */
name: string; 
/**
 * Full path to the file
 */
path: string; 
/**
 * File content
 */
content: string; 
/**
 * Last modified timestamp in milliseconds
 */
modifiedAt: number }
/**
 * Token usage statistics
 */
export type TokenUsage = { inputTokens: number; outputTokens: number; cacheCreationTokens: number; cacheReadTokens: number; thinkingTokens: number }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
